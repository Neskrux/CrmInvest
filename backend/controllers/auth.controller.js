const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { supabaseAdmin } = require('../config/database');
const { JWT_SECRET } = require('../config/constants');
const { normalizarEmail } = require('../utils/helpers');
const transporter = require('../config/email');
const { logLoginAttempt, logError, isDevelopment } = require('../utils/logger');

// Login
const login = async (req, res) => {
  try {
    const { email, senha } = req.body;

    if (!email || !senha) {
      return res.status(400).json({ error: 'Nome/Email e senha s√£o obrigat√≥rios' });
    }

    const emailNormalizado = normalizarEmail(email);
    
    // Log seguro (sem dados sens√≠veis em produ√ß√£o)
    if (isDevelopment) {
      console.log('üîê ==========================================');
      console.log('üîê TENTATIVA DE LOGIN');
      console.log('üîê Email:', emailNormalizado);
      console.log('üîê Timestamp:', new Date().toISOString());
      console.log('üîê ==========================================');
    }

    let usuario = null;
    let tipoLogin = null;

    // Primeiro, tentar login como admin (por email)
    if (typeof email === 'string' && email.includes('@')) {
      if (isDevelopment) console.log('üîç [1/3] Buscando em ADMIN...');
      const { data: usuarios, error } = await supabaseAdmin
        .from('usuarios')
        .select(`
          *,
          consultores(nome, telefone)
        `)
        .eq('email', emailNormalizado)
        .eq('ativo', true);

      if (error) {
        logError(error, 'Erro ao buscar em usuarios');
        throw error;
      }

      if (isDevelopment) {
        console.log('üîç Resultados em ADMIN:', usuarios ? usuarios.length : 0);
      }

      if (usuarios && usuarios.length > 0) {
        if (usuarios.length > 1) {
          console.error('‚ö†Ô∏è ALERTA: M√∫ltiplos admins com o mesmo email!');
          if (isDevelopment) {
            console.error('Detalhes:', usuarios.map(u => ({ id: u.id, email: u.email })));
          }
        }
        usuario = usuarios[0];
        tipoLogin = 'admin';
        if (isDevelopment) {
          console.log('‚úÖ Usu√°rio encontrado em: ADMIN');
          console.log('üìã ID:', usuario.id, '| Nome:', usuario.nome);
        }
      }
    }

    // Se n√£o encontrou admin, tentar login como cl√≠nica
    if (!usuario && typeof email === 'string' && email.includes('@')) {
      if (isDevelopment) console.log('üîç [2/4] Buscando em CL√çNICAS...');
      
      const { data: clinicas, error } = await supabaseAdmin
        .from('clinicas')
        .select('*')
        .eq('email_login', emailNormalizado)
        .eq('ativo_no_sistema', true);

      if (error) {
        logError(error, 'Erro ao buscar em cl√≠nicas');
        throw error;
      }

      if (isDevelopment) {
        console.log('üîç Resultados em CL√çNICAS:', clinicas ? clinicas.length : 0);
      }

      if (clinicas && clinicas.length > 0) {
        if (clinicas.length > 1) {
          console.error('‚ö†Ô∏è ALERTA: M√∫ltiplas cl√≠nicas com o mesmo email!');
          if (isDevelopment) {
            console.error('Detalhes:', clinicas.map(c => ({ id: c.id, email: c.email_login })));
          }
        }
        usuario = clinicas[0];
        tipoLogin = 'clinica';
        if (isDevelopment) {
          console.log('‚úÖ Usu√°rio encontrado em: CL√çNICA');
          console.log('üìã ID:', usuario.id, '| Nome:', usuario.nome);
        }
        
        // Atualizar √∫ltimo acesso da cl√≠nica
        await supabaseAdmin
          .from('clinicas')
          .update({ ultimo_acesso: new Date().toISOString() })
          .eq('id', usuario.id);
      } else {
        console.log('‚ùå N√£o encontrado em cl√≠nicas');
      }
    }

    // Se n√£o encontrou admin nem cl√≠nica, tentar login como empresa (multi-tenancy)
    if (!usuario && typeof email === 'string' && email.includes('@')) {
      if (isDevelopment) console.log('üîç [3/5] Buscando em EMPRESA (multi-tenancy)...');
      
      const { data: empresas, error } = await supabaseAdmin
        .from('empresa')
        .select('*')
        .eq('email', emailNormalizado)
        .eq('ativo', true);

      if (error) {
        logError(error, 'Erro ao buscar em empresa');
        throw error;
      }

      if (isDevelopment) {
        console.log('üîç Resultados em EMPRESA:', empresas ? empresas.length : 0);
      }

      if (empresas && empresas.length > 0) {
        if (empresas.length > 1) {
          console.error('‚ö†Ô∏è ALERTA: M√∫ltiplas empresas com o mesmo email!');
          if (isDevelopment) {
            console.error('Detalhes:', empresas.map(e => ({ id: e.id, email: e.email })));
          }
        }
        usuario = empresas[0];
        tipoLogin = 'empresa';
        if (isDevelopment) {
          console.log('‚úÖ Usu√°rio encontrado em: EMPRESA (multi-tenancy)');
          console.log('üìã ID:', usuario.id, '| Nome:', usuario.nome);
        }
      } else {
        if (isDevelopment) console.log('‚ùå N√£o encontrado em empresa');
      }
    }

    // Se n√£o encontrou admin, cl√≠nica nem empresa, tentar login como parceiro
    if (!usuario && typeof email === 'string' && email.includes('@')) {
      if (isDevelopment) console.log('üîç [4/5] Buscando em PARCEIROS...');
      
      const { data: parceiros, error } = await supabaseAdmin
        .from('parceiros')
        .select('*')
        .eq('email', emailNormalizado)
        .eq('ativo', true);

      if (error) {
        logError(error, 'Erro ao buscar em parceiros');
        throw error;
      }

      if (isDevelopment) {
        console.log('üîç Resultados em PARCEIROS:', parceiros ? parceiros.length : 0);
      }

      if (parceiros && parceiros.length > 0) {
        if (parceiros.length > 1) {
          console.error('‚ö†Ô∏è ALERTA: M√∫ltiplas parceiros com o mesmo email!');
          if (isDevelopment) {
            console.error('Detalhes:', parceiros.map(e => ({ id: e.id, email: e.email })));
          }
        }
        usuario = parceiros[0];
        tipoLogin = 'parceiro';
        if (isDevelopment) {
          console.log('‚úÖ Usu√°rio encontrado em: PARCEIRO');
          console.log('üìã ID:', usuario.id, '| Nome:', usuario.nome);
        }
      } else {
        if (isDevelopment) console.log('‚ùå N√£o encontrado em parceiros');
      }
    }

    // Se n√£o encontrou admin, cl√≠nica, empresa nem parceiro, tentar login como consultor
    if (!usuario && typeof email === 'string' && email.includes('@')) {
      if (isDevelopment) console.log('üîç [5/5] Buscando em CONSULTORES...');
      
      const { data: consultores, error } = await supabaseAdmin
        .from('consultores')
        .select('*')
        .eq('email', emailNormalizado)
        .eq('ativo', true);

      if (error) {
        logError(error, 'Erro ao buscar em consultores');
        throw error;
      }

      if (isDevelopment) {
        console.log('üîç Resultados em CONSULTORES:', consultores ? consultores.length : 0);
      }

      if (consultores && consultores.length > 0) {
        if (consultores.length > 1) {
          console.error('‚ö†Ô∏è ALERTA CR√çTICO: M√∫ltiplos consultores com o mesmo email!');
          if (isDevelopment) {
            console.error('Detalhes:', consultores.map(c => ({ id: c.id, nome: c.nome, email: c.email })));
          }
        }
        usuario = consultores[0];
        tipoLogin = 'consultor';
        if (isDevelopment) {
          console.log('‚úÖ Usu√°rio encontrado em: CONSULTOR');
          console.log('üìã ID:', usuario.id, '| Nome:', usuario.nome);
        }
      } else {
        if (isDevelopment) console.log('‚ùå N√£o encontrado em consultores');
      }
    }

    if (isDevelopment) console.log('üìã Tipo de login detectado:', tipoLogin);

    if (!usuario) {
      logLoginAttempt(emailNormalizado, false);
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    // Verificar senha (diferente para cl√≠nicas que usam senha_hash)
    let senhaValida = false;
    
    if (tipoLogin === 'clinica') {
      // Cl√≠nicas usam o campo senha_hash
      senhaValida = await bcrypt.compare(senha, usuario.senha_hash);
    } else {
      // Outros usu√°rios usam o campo senha
      senhaValida = await bcrypt.compare(senha, usuario.senha);
    }
    
    if (!senhaValida) {
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    // Atualizar √∫ltimo login
    try {
      await supabaseAdmin
        .from('usuarios')
        .update({ ultimo_login: new Date().toISOString() })
        .eq('id', usuario.id);
    } catch (error) {
      logError(error, 'Erro ao atualizar ultimo_login');
    }

    // Padronizar payload e resposta para compatibilidade com Meta Ads
    const payload = {
      id: usuario.id,
      nome: usuario.nome,
      email: tipoLogin === 'clinica' ? usuario.email_login : usuario.email,
      tipo: tipoLogin === 'empresa' ? 'empresa' : (tipoLogin === 'parceiro' ? 'parceiro' : (tipoLogin === 'clinica' ? 'clinica' : usuario.tipo)),
      clinica_id: tipoLogin === 'clinica' ? usuario.id : null,
      consultor_id: usuario.consultor_id !== undefined ? usuario.consultor_id : (tipoLogin === 'consultor' ? usuario.id : null),
      empresa_id: tipoLogin === 'empresa' ? usuario.id : (usuario.empresa_id || null),
      podealterarstatus: (tipoLogin === 'empresa' || tipoLogin === 'parceiro' || tipoLogin === 'clinica') ? false : (usuario.podealterarstatus || usuario.tipo === 'admin' || false),
      pode_ver_todas_novas_clinicas: (tipoLogin === 'empresa' || tipoLogin === 'parceiro' || tipoLogin === 'clinica') ? false : (usuario.pode_ver_todas_novas_clinicas || false),
      is_freelancer: (tipoLogin === 'admin' || tipoLogin === 'empresa' || tipoLogin === 'parceiro' || tipoLogin === 'clinica') ? false : (usuario.is_freelancer === true)
    };

    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '12h' });

    // Remover senha do objeto antes de enviar para o front
    delete usuario.senha;
    delete usuario.senha_hash;

    // Garante que usuario.tipo, consultor_id, empresa_id, clinica_id, podealterarstatus, pode_ver_todas_novas_clinicas e is_freelancer tamb√©m estejam presentes no objeto de resposta
    usuario.tipo = payload.tipo;
    usuario.consultor_id = payload.consultor_id;
    usuario.empresa_id = payload.empresa_id;
    usuario.clinica_id = payload.clinica_id;
    usuario.podealterarstatus = payload.podealterarstatus;
    usuario.pode_ver_todas_novas_clinicas = payload.pode_ver_todas_novas_clinicas;
    usuario.is_freelancer = payload.is_freelancer;

    console.log('‚úÖ Login bem-sucedido! Tipo:', usuario.tipo);
    console.log('üìã Usuario retornado para o frontend:', {
      id: usuario.id,
      nome: usuario.nome,
      tipo: usuario.tipo,
      clinica_id: usuario.clinica_id,
      email: usuario.email || usuario.email_login
    });

    res.json({ token, usuario });

  } catch (error) {
    console.error('Erro no login:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

// Logout
const logout = (req, res) => {
  // Com JWT stateless, o logout √© feito removendo o token do cliente
  res.json({ message: 'Logout realizado com sucesso' });
};

// Verify Token
const verifyToken = async (req, res) => {
  try {
    let usuario = null;
    let tipo = req.user.tipo;
    let consultor_id = null;

    // CR√çTICO: Usar o tipo do token para buscar na tabela correta
    if (req.user.tipo === 'admin') {
      const { data: usuarioData } = await supabaseAdmin
        .from('usuarios')
        .select('*')
        .eq('id', req.user.id)
        .eq('ativo', true)
        .single();

      if (usuarioData) {
        usuario = usuarioData;
        consultor_id = usuario.consultor_id || null;
      }
    } else if (req.user.tipo === 'empresa') {
      const { data: empresaData } = await supabaseAdmin
        .from('empresa')
        .select('*')
        .eq('id', req.user.id)
        .eq('ativo', true)
        .single();

      if (empresaData) {
        usuario = empresaData;
        tipo = 'empresa';
        consultor_id = null;
      }
    } else if (req.user.tipo === 'parceiro') {
      const { data: empresaData } = await supabaseAdmin
        .from('parceiros')
        .select('*')
        .eq('id', req.user.id)
        .eq('ativo', true)
        .single();

      if (empresaData) {
        usuario = empresaData;
        tipo = 'parceiro';
        consultor_id = null;
      }
    } else if (req.user.tipo === 'consultor') {
      const { data: consultorData } = await supabaseAdmin
        .from('consultores')
        .select('*')
        .eq('id', req.user.id)
        .eq('ativo', true)
        .single();

      if (consultorData) {
        usuario = consultorData;
        tipo = 'consultor';
        consultor_id = usuario.id;
      }
    } else if (req.user.tipo === 'clinica') {
      const { data: clinicaData } = await supabaseAdmin
        .from('clinicas')
        .select('*')
        .eq('id', req.user.id)
        .single();

      if (clinicaData) {
        usuario = clinicaData;
        tipo = 'clinica';
        consultor_id = clinicaData.consultor_id || null;
      }
    }

    if (!usuario) {
      return res.status(401).json({ error: 'Usu√°rio n√£o encontrado' });
    }

    // Remover senha do objeto antes de enviar para o front
    const { senha: _, senha_hash: __, ...dadosUsuario } = usuario;

    res.json({
      usuario: {
        ...dadosUsuario,
        email: tipo === 'clinica' ? usuario.email_login : usuario.email,
        tipo,
        consultor_id,
        empresa_id: tipo === 'empresa' ? usuario.id : (usuario.empresa_id || null),
        clinica_id: tipo === 'clinica' ? usuario.id : null,
        podealterarstatus: (tipo === 'empresa' || tipo === 'parceiro' || tipo === 'clinica') ? false : (usuario.podealterarstatus || tipo === 'admin' || false),
        pode_ver_todas_novas_clinicas: (tipo === 'empresa' || tipo === 'parceiro' || tipo === 'clinica') ? false : (usuario.pode_ver_todas_novas_clinicas || false),
        is_freelancer: (tipo === 'admin' || tipo === 'empresa' || tipo === 'parceiro' || tipo === 'clinica') ? false : (usuario.is_freelancer === true)
      }
    });
  } catch (error) {
    console.error('‚ùå Erro ao verificar token:', error);
    res.status(500).json({ error: error.message });
  }
};

// Forgot Password
const forgotPassword = async (req, res) => {
  try {
    if (isDevelopment) console.log('üîß POST /api/forgot-password recebido');
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ error: 'Email √© obrigat√≥rio' });
    }

    // Verificar se o consultor existe
    if (isDevelopment) console.log('üîß Buscando consultor com email:', email);
    const { data: user, error: userError } = await supabaseAdmin
      .from('consultores')
      .select('id, nome, email')
      .eq('email', email)
      .single();

    if (isDevelopment) {
      console.log('üîß Resultado da busca:', { user: user ? 'encontrado' : 'n√£o encontrado', userError });
    }

    if (userError || !user) {
      if (isDevelopment) console.log('üîß Consultor n√£o encontrado, retornando mensagem de seguran√ßa');
      // Por seguran√ßa, sempre retorna sucesso mesmo se o email n√£o existir
      return res.json({ 
        message: 'Se o email estiver cadastrado, voc√™ receber√° instru√ß√µes para redefinir sua senha.' 
      });
    }

    if (isDevelopment) console.log('‚úÖ Consultor encontrado');

    // Gerar token de redefini√ß√£o com timestamp para expira√ß√£o
    const resetToken = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 horas
    
    // Salvar token no banco de dados
    if (isDevelopment) console.log('üîß Tentando salvar token no banco...');
    const { error: tokenError } = await supabaseAdmin
      .from('password_reset_tokens')
      .insert([{
        user_id: user.id,
        token: resetToken,
        expires_at: expiresAt.toISOString(),
        used: false
      }]);

    if (tokenError) {
      logError(tokenError, 'Erro ao salvar token de reset');
      if (isDevelopment) console.log('üîß Continuando mesmo com erro no banco...');
    } else {
      if (isDevelopment) console.log('‚úÖ Token salvo no banco com sucesso');
    }

    // Enviar email real
    const resetLink = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password?token=${resetToken}`;
    if (isDevelopment) {
      console.log('üîß Preparando envio de email...');
      console.log('üîß Reset link:', resetLink);
    }
    
    const mailOptions = {
      from: `"Solumn" <${process.env.EMAIL_FROM}>`,
      to: email,
      subject: 'Redefini√ß√£o de Senha - Solumn',
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #1a1d23;">Redefini√ß√£o de Senha</h2>
          <p>Ol√° ${user.nome},</p>
          <p>Voc√™ solicitou a redefini√ß√£o de sua senha. Clique no bot√£o abaixo para criar uma nova senha:</p>
          <div style="text-align: center; margin: 30px 0;">
            <a href="${resetLink}" style="background-color: #1a1d23; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
              Redefinir Senha
            </a>
          </div>
          <p>Ou copie e cole este link no seu navegador:</p>
          <p style="word-break: break-all; color: #666;">${resetLink}</p>
          <p><strong>Este link expira em 24 horas.</strong></p>
          <p>Se voc√™ n√£o solicitou esta redefini√ß√£o, ignore este email.</p>
          <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
          <p style="color: #666; font-size: 12px;">Este √© um email autom√°tico, n√£o responda.</p>
        </div>
      `
    };

    try {
      // Verificar se est√° em ambiente de desenvolvimento e se email n√£o est√° configurado
      const isEmailConfigured = process.env.EMAIL_USER && 
                                process.env.EMAIL_USER !== 'your-email@gmail.com' && 
                                process.env.EMAIL_PASS && 
                                process.env.EMAIL_PASS !== 'your-app-password';

      if (isDevelopment) {
        console.log('üîß Verifica√ß√£o de configura√ß√£o de email:', {
          EMAIL_SERVICE: process.env.EMAIL_SERVICE,
          isEmailConfigured,
          NODE_ENV: process.env.NODE_ENV
        });
      }

      if (!isEmailConfigured && process.env.NODE_ENV === 'development') {
        console.log('üîß EMAIL N√ÉO CONFIGURADO - MODO DESENVOLVIMENTO');
        console.log('üìß ========================================');
        console.log('üìß LINK DE REDEFINI√á√ÉO DE SENHA:');
        console.log(`üìß ${resetLink}`);
        console.log('üìß ========================================');
        console.log('üìß Copie o link acima e cole no navegador para redefinir a senha');
        console.log('üìß Para configurar o envio de email, veja o arquivo EMAIL_SETUP.md');
      } else {
        if (isDevelopment) {
          console.log('üîß Tentando enviar email via SendGrid...');
          console.log('üîß Configura√ß√£o do transporter:', {
            service: process.env.EMAIL_SERVICE,
            from: mailOptions.from
          });
        }
        
        const result = await transporter.sendMail(mailOptions);
        if (isDevelopment) {
          console.log('‚úÖ Email enviado com sucesso!', result);
          console.log('‚úÖ Email de redefini√ß√£o enviado');
        }
      }
    } catch (emailError) {
      logError(emailError, 'Erro ao enviar email');
      
      // Em desenvolvimento, mostrar o link mesmo se o email falhar
      if (process.env.NODE_ENV === 'development') {
        console.log('üîß FALHA NO EMAIL - MODO DESENVOLVIMENTO');
        console.log('üìß ========================================');
        console.log('üìß LINK DE REDEFINI√á√ÉO DE SENHA:');
        console.log(`üìß ${resetLink}`);
        console.log('üìß ========================================');
        console.log('üìß Copie o link acima e cole no navegador para redefinir a senha');
      }
    }
    
    res.json({ 
      message: 'Instru√ß√µes para redefini√ß√£o de senha foram enviadas para seu email.' 
    });

  } catch (error) {
    console.error('Erro ao processar solicita√ß√£o de redefini√ß√£o de senha:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

// Validate Reset Token
const validateResetToken = async (req, res) => {
  try {
    const { token } = req.body;

    if (!token) {
      return res.status(400).json({ error: 'Token √© obrigat√≥rio' });
    }

    // Buscar token no banco de dados
    const { data: tokenData, error: tokenError } = await supabaseAdmin
      .from('password_reset_tokens')
      .select('*')
      .eq('token', token)
      .eq('used', false)
      .single();

    if (tokenError || !tokenData) {
      return res.status(400).json({ error: 'Token inv√°lido ou n√£o encontrado' });
    }

    // Verificar se o token n√£o expirou
    const now = new Date();
    const expiresAt = new Date(tokenData.expires_at);

    if (now > expiresAt) {
      return res.status(400).json({ error: 'Token expirado' });
    }

    res.json({ message: 'Token v√°lido' });

  } catch (error) {
    console.error('Erro ao validar token:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

// Reset Password
const resetPassword = async (req, res) => {
  try {
    const { token, novaSenha } = req.body;

    if (!token || !novaSenha) {
      return res.status(400).json({ error: 'Token e nova senha s√£o obrigat√≥rios' });
    }

    if (novaSenha.length < 6) {
      return res.status(400).json({ error: 'A senha deve ter pelo menos 6 caracteres' });
    }

    // Buscar token no banco de dados
    const { data: tokenData, error: tokenError } = await supabaseAdmin
      .from('password_reset_tokens')
      .select('*')
      .eq('token', token)
      .eq('used', false)
      .single();

    if (tokenError || !tokenData) {
      return res.status(400).json({ error: 'Token inv√°lido ou n√£o encontrado' });
    }

    // Verificar se o token n√£o expirou
    const now = new Date();
    const expiresAt = new Date(tokenData.expires_at);

    if (now > expiresAt) {
      return res.status(400).json({ error: 'Token expirado' });
    }

    // Buscar o consultor
    const { data: consultor, error: consultorError } = await supabaseAdmin
      .from('consultores')
      .select('*')
      .eq('id', tokenData.user_id)
      .single();

    if (consultorError || !consultor) {
      return res.status(404).json({ error: 'Consultor n√£o encontrado' });
    }

    // Hash da nova senha
    const hashedPassword = await bcrypt.hash(novaSenha, 10);

    // Atualizar senha do consultor
    const { error: updateError } = await supabaseAdmin
      .from('consultores')
      .update({ senha: hashedPassword })
      .eq('id', tokenData.user_id);

    if (updateError) {
      throw updateError;
    }

    // Marcar token como usado
    const { error: tokenUpdateError } = await supabaseAdmin
      .from('password_reset_tokens')
      .update({ used: true })
      .eq('token', token);

    if (tokenUpdateError) {
      console.error('Erro ao marcar token como usado:', tokenUpdateError);
    }

    console.log(`‚úÖ Senha redefinida com sucesso para o consultor ${consultor.nome}`);
    res.json({ message: 'Senha redefinida com sucesso' });

  } catch (error) {
    console.error('Erro ao redefinir senha:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
};

module.exports = {
  login,
  logout,
  verifyToken,
  forgotPassword,
  validateResetToken,
  resetPassword
};

